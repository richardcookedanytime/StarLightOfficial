#!/usr/bin/env python3
"""
Starlight 编程语言 - JavaScript 后端代码生成器
负责将 AST 转换为 JavaScript 代码
"""

import os
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from .parser import *
from .semantic_analyzer import SemanticAnalyzer

class JavaScriptCodeGenerator:
    def __init__(self):
        self.output_dir = "build"
        self.js_code = []
        self.functions = []
        self.global_vars = []
        
    def generate(self, program: Program, module_name: str = "main") -> str:
        """生成 JavaScript 代码"""
        self.js_code = []
        self.functions = []
        self.global_vars = []
        
        # 生成模块头
        self._generate_module_header(module_name)
        
        # 生成函数定义
        for stmt in program.statements:
            if isinstance(stmt, FunctionDeclaration):
                self._generate_function(stmt)
        
        # 生成 main 函数调用
        self._generate_main_call(program)
        
        # 生成模块尾
        self._generate_module_footer()
        
        return "\n".join(self.js_code)
    
    def _generate_module_header(self, module_name: str):
        """生成模块头"""
        self.js_code.append("// Generated by Starlight JavaScript Backend")
        self.js_code.append(f"// Module: {module_name}")
        self.js_code.append("")
        
        # ES6 模块导出
        self.js_code.append("export { main };")
        self.js_code.append("")
    
    def _generate_module_footer(self):
        """生成模块尾"""
        pass
    
    def _generate_function(self, func: FunctionDeclaration):
        """生成函数"""
        # 生成函数签名
        params = [param_name for param_name, _ in func.parameters]
        param_list = ", ".join(params)
        
        # 如果是 main 函数，特殊处理
        if func.name == "main":
            self.js_code.append("function main() {")
        else:
            self.js_code.append(f"function {func.name}({param_list}) {{")
        
        # 生成函数体
        self._generate_function_body(func.body, indent="    ")
        
        self.js_code.append("}")
        self.js_code.append("")
    
    def _generate_function_body(self, body: List[Statement], indent: str = ""):
        """生成函数体"""
        for stmt in body:
            self._generate_statement(stmt, indent)
    
    def _generate_statement(self, stmt: Statement, indent: str = ""):
        """生成语句"""
        if isinstance(stmt, VariableDeclaration):
            self._generate_variable_declaration(stmt, indent)
        elif isinstance(stmt, ReturnStatement):
            self._generate_return_statement(stmt, indent)
        elif isinstance(stmt, ExpressionStatement):
            self._generate_expression_statement(stmt, indent)
        elif isinstance(stmt, IfStatement):
            self._generate_if_statement(stmt, indent)
        elif isinstance(stmt, WhileStatement):
            self._generate_while_statement(stmt, indent)
        elif isinstance(stmt, BlockStatement):
            self._generate_block_statement(stmt, indent)
    
    def _generate_variable_declaration(self, var: VariableDeclaration, indent: str):
        """生成变量声明"""
        if var.is_const:
            keyword = "const"
        else:
            keyword = "let"
        
        if var.initializer:
            expr_code = self._generate_expression(var.initializer)
            self.js_code.append(f"{indent}{keyword} {var.name} = {expr_code};")
        else:
            self.js_code.append(f"{indent}{keyword} {var.name};")
    
    def _generate_return_statement(self, ret: ReturnStatement, indent: str):
        """生成返回语句"""
        if ret.value:
            expr_code = self._generate_expression(ret.value)
            self.js_code.append(f"{indent}return {expr_code};")
        else:
            self.js_code.append(f"{indent}return;")
    
    def _generate_expression_statement(self, expr_stmt: ExpressionStatement, indent: str):
        """生成表达式语句"""
        expr_code = self._generate_expression(expr_stmt.expression)
        self.js_code.append(f"{indent}{expr_code};")
    
    def _generate_if_statement(self, if_stmt: IfStatement, indent: str):
        """生成 if 语句"""
        condition = self._generate_expression(if_stmt.condition)
        self.js_code.append(f"{indent}if ({condition}) {{")
        
        for stmt in if_stmt.then_branch:
            self._generate_statement(stmt, indent + "    ")
        
        if if_stmt.else_branch:
            self.js_code.append(f"{indent}}} else {{")
            for stmt in if_stmt.else_branch:
                self._generate_statement(stmt, indent + "    ")
        
        self.js_code.append(f"{indent}}}")
    
    def _generate_while_statement(self, while_stmt: WhileStatement, indent: str):
        """生成 while 语句"""
        condition = self._generate_expression(while_stmt.condition)
        self.js_code.append(f"{indent}while ({condition}) {{")
        
        for stmt in while_stmt.body:
            self._generate_statement(stmt, indent + "    ")
        
        self.js_code.append(f"{indent}}}")
    
    def _generate_block_statement(self, block: BlockStatement, indent: str):
        """生成块语句"""
        for stmt in block.statements:
            self._generate_statement(stmt, indent)
    
    def _generate_expression(self, expr: Expression) -> str:
        """生成表达式"""
        if isinstance(expr, Identifier):
            return expr.name
        elif isinstance(expr, Literal):
            return self._generate_literal(expr)
        elif isinstance(expr, BinaryOp):
            return self._generate_binary_op(expr)
        elif isinstance(expr, UnaryOp):
            return self._generate_unary_op(expr)
        elif isinstance(expr, Call):
            return self._generate_call(expr)
        else:
            return "/* unknown expression */"
    
    def _generate_literal(self, literal: Literal) -> str:
        """生成字面量"""
        if literal.type == "string":
            return f'"{literal.value}"'
        elif literal.type == "boolean":
            return "true" if literal.value else "false"
        elif literal.type == "null":
            return "null"
        else:
            return str(literal.value)
    
    def _generate_binary_op(self, op: BinaryOp) -> str:
        """生成二元操作"""
        left = self._generate_expression(op.left)
        right = self._generate_expression(op.right)
        
        # 操作符映射
        operator_mapping = {
            '+': '+',
            '-': '-',
            '*': '*',
            '/': '/',
            '%': '%',
            '==': '===',  # JavaScript 严格相等
            '!=': '!==',  # JavaScript 严格不等
            '<': '<',
            '>': '>',
            '<=': '<=',
            '>=': '>=',
            '&&': '&&',
            '||': '||'
        }
        
        js_op = operator_mapping.get(op.operator, op.operator)
        return f"({left} {js_op} {right})"
    
    def _generate_unary_op(self, op: UnaryOp) -> str:
        """生成一元操作"""
        operand = self._generate_expression(op.operand)
        
        if op.operator == '!':
            return f"!({operand})"
        elif op.operator == '-':
            return f"-({operand})"
        else:
            return f"{op.operator}({operand})"
    
    def _generate_call(self, call: Call) -> str:
        """生成函数调用"""
        callee = self._generate_expression(call.callee)
        args = [self._generate_expression(arg) for arg in call.arguments]
        
        # 处理内置函数
        if isinstance(call.callee, Identifier):
            if call.callee.name == "println":
                return f"console.log({', '.join(args)})"
            elif call.callee.name == "print":
                return f"process.stdout.write({', '.join(args)})"
        
        return f"{callee}({', '.join(args)})"
    
    def _generate_main_call(self, program: Program):
        """生成 main 函数调用"""
        # 检查是否有 main 函数
        has_main = False
        for stmt in program.statements:
            if isinstance(stmt, FunctionDeclaration) and stmt.name == "main":
                has_main = True
                break
        
        if has_main:
            self.js_code.append("// Auto-call main function")
            self.js_code.append("main();")
    
    def save_to_file(self, js_code: str, filename: str = None):
        """保存 JavaScript 代码到文件"""
        if filename is None:
            filename = "main.js"
        
        os.makedirs(self.output_dir, exist_ok=True)
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(js_code)
        
        return filepath

def generate_javascript_code(program: Program, module_name: str = "main") -> str:
    """生成 JavaScript 代码"""
    generator = JavaScriptCodeGenerator()
    return generator.generate(program, module_name)

if __name__ == "__main__":
    # 测试 JavaScript 后端
    from lexer import Lexer
    from parser import Parser
    from semantic_analyzer import SemanticAnalyzer
    
    test_code = '''
    func greet(name) {
        return "Hello, " + name;
    }
    
    func main() {
        let message = greet("World");
        println(message);
    }
    '''
    
    # 词法分析
    lexer = Lexer(test_code)
    tokens = lexer.tokenize()
    
    # 语法分析
    parser = Parser(tokens)
    ast = parser.parse()
    
    # 语义分析
    analyzer = SemanticAnalyzer()
    semantic_result = analyzer.analyze(ast)
    
    if semantic_result['success']:
        # 生成 JavaScript 代码
        generator = JavaScriptCodeGenerator()
        js_code = generator.generate(ast, "hello")
        
        print("=== 生成的 JavaScript 代码 ===")
        print(js_code)
        
        # 保存到文件
        filepath = generator.save_to_file(js_code, "hello.js")
        print(f"\n✅ JavaScript 代码已保存到: {filepath}")
    else:
        print("❌ 语义分析失败:")
        for error in semantic_result['errors']:
            print(f"  - {error['message']}")
